package IDEA_Useful;

public class useful {

    //Ctrl + Alt + V - быстрое создание переменной
    //Ctrl + [Пробел] - Idea покажет какие методы есть в классе
    //Ctrl + D - копирут строку на которой находитесь
    //Ctrl + Y - удаляет строку на которой находитесь
    //Ctrl + O - вызов генератора Оверайт методов
    //Ctrl + Q + установить курсор - можем смотреть документацию про элементы
    //Ctrl + Alt + L - форматирует код, чтобы боло все читабельно
    //Ctrl + Alt + T - вызов Surround With (метод для обворачивания)
    //Alt + insert - вызываем генератор для быстрово создания элементов
    //Shift + f6 - для того чтобы переименовать элемент во всех местах где он используеться
    //Ctrl + /, Ctrl + Shift + / - быстрое комментирование
    //Alt + Enter + курсор - можем быстро написать import для класса

    /* 1) Если элемент static он создаеться с самого начала, можем к нему обращаться
     использовав класс, а не объект класса и это атрибут класса, а не объекта
     что это дает, к примеру можем использовать нумерацию сквозь все объекты, что мы создаем*/

    /*2) Примитивные типи в начале инициализируються всега = 0, а тип object = null */

    /*3) Все констатны именнуем буквами верхнего регистра и когда два слова используем _ */

    /*4) Импорт всех класов с пакета происходит при помощи *, будет import java.until.*;     */

    /*5) Еще можем делать импорт статических членов класса для этого после import указываем static
    и можем не указывать название класса в начале для вызова метода*/

    /*6) Не вызываем метод с конструкторов это плохой тон, методы отдельно, конструкторы отдельно*/

    /*7)Метод оверлодинг, это когда у нас перегрузка метода, и из одного метода,
    мы вызываем метод с таким же названием но с другой сигнатурой метода и это уже не рекурсия*/

    /*8)Метод оверайдинг, это когда переопределяем метод с такой же сигнатурой который есть в родительском классе
    1.для оверайдинга имя метода и параметры должны совпадать.
    2. модификатор доступа должен быть не private его не будет видно в подклассе,
    для переопределенного метода модификатор доступа можно увеличивать по доступности но не на оборот
    3.в return type можем возвращать подклас того типа который указан у нас в супер классе  */

    /*9)1.В интерфейсе все методы абстрактные и по умолчанию public ,так что это мы можем не указывать
    2.В интерфейсе нет конструктора, могут быть только переменные константы и статик, которые
    обезательно нужно определить. 3.Можно имплементироать несколько интерфейсов в этом и есть его плюс
    4.интерфейсы могут наследовать друг друга, и наследовать можно не только один интерфейс, а несколько .*/

    /*10) Изминения в интерфейсах JAVA 8:
    1.Функциональный интерфейс когда в нем только один абстрактный метод
    2.в default методах мы делаем имплементацию внутри интерфейсов, они уже не являються абстрактными
    3.можно создавать static методы, и тоже делаем их имплиментацию */

    /*11) 1.Когда объявляем класс внутри метода мы должны использовать дефолтный модификатор доступа
    2.Анонимные классы очень важны для лямбда выражений*/

    /*12)В блок finally помещаем код который должен быть выполнен внезависимости успешно ли выполница блок try или нет
    2.Хорошая практика не обрабатывать exeption сразу иногда его лучше пробросить через главный метод по иерархии*/
}
